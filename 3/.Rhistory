# generate a fake data set
dataSize <- 5
fakeData <- rnorm(dataSize, mean = 5.03, sd = 49.1231)
dataSampVar <- var(fakeData) # s^2
dataMean <- mean(fakeData) # ybar
# regular Monte Carlo:
# simulate from # simulate from p(ytilde, mu, ss | y)
# and take the mean
library(invgamma)
# simulate from p(ytilde, mu, ss | y) = p(ytilde | mu, ss)p(mu | ss, y)p(ss | y)
numSamps <- 10
getOneEstimator.v1 <- function(numSamps, dataMean, dataSampVar){
sigmaSquareds <- rinvgamma(n = numSamps, shape = .5*(dataSize - 1), rate = .5*(dataSize-1)*dataSampVar)
mus <- rnorm(n = numSamps, mean = dataMean, sd = sqrt(sigmaSquareds/dataSize)) # note the changing variances
ytildes <- rnorm(n = numSamps, mean = mus, sd = sqrt(sigmaSquareds/dataSize)) # changing means and variances
mean(ytildes)
}
# let's do this over and over again,
# so we can get a sense of the dispersion of this estimator
regMonteCarloEstimators <- replicate(1e5,
getOneEstimator.v1(numSamps, dataMean, dataSampVar))
# simulate from p(mu, ss | y) = p(mu | ss, y)p(ss | y)
# use the fact that E[ytilde | mu, ss] = mu
getOneEstimator.v2 <- function(numSamps, dataMean, dataSampVar){
sigmaSquareds <- rinvgamma(n = numSamps, shape = .5*(dataSize - 1), rate = .5*(dataSize-1)*dataSampVar)
mus <- rnorm(n = numSamps, mean = dataMean, sd = sqrt(sigmaSquareds/dataSize)) # note the changing variances
estimator <- mean(mus)
}
RBEstimators <- replicate(1e5, getOneEstimator.v2(numSamps, dataMean, dataSampVar))
# compare the three estimators
p1 <- hist(regMonteCarloEstimators)
p2 <- hist(RBEstimators)
plot(p1, col=rgb(0,0,1,1/4), xlim=c(-100,100),
main = "Monte Carlo: Naive versus RB",
xlab = "estimator value")  # first histogram
plot(p2, col=rgb(1,0,0,1/4), xlim=c(-100,100), add=T)  # second
# simulate from p(mu, ss | y) = p(mu | ss, y)p(ss | y)
# use the fact that E[ytilde | mu, ss] = mu
getOneEstimator.v2 <- function(numSamps, dataMean, dataSampVar){
sigmaSquareds <- rinvgamma(n = numSamps, shape = .5*(dataSize - 1), rate = .5*(dataSize-1)*dataSampVar)
mus <- rnorm(n = numSamps, mean = dataMean, sd = sqrt(sigmaSquareds/dataSize)) # note the changing variances
mean(mus)
}
RBEstimators <- replicate(1e5, getOneEstimator.v2(numSamps, dataMean, dataSampVar))
# compare the three estimators
p1 <- hist(regMonteCarloEstimators)
p2 <- hist(RBEstimators)
plot(p1, col=rgb(0,0,1,1/4), xlim=c(-100,100),
main = "Monte Carlo: Naive versus RB",
xlab = "estimator value")  # first histogram
plot(p2, col=rgb(1,0,0,1/4), xlim=c(-100,100), add=T)  # second
plot(p1, col=rgb(0,0,1,1/4), xlim=c(-100,100),
main = "Monte Carlo: Naive versus RB",
xlab = "estimator value")  # first histogram
# compare the three estimators
p1 <- hist(regMonteCarloEstimators, freq = T)
p2 <- hist(RBEstimators, freq = T)
plot(p1, col=rgb(0,0,1,1/4), xlim=c(-100,100),
main = "Monte Carlo: Naive versus RB",
xlab = "estimator value")  # first histogram
plot(p2, col=rgb(1,0,0,1/4), xlim=c(-100,100), add=T)  # second
# compare the three estimators
p1 <- hist(regMonteCarloEstimators, freq = F)
p2 <- hist(RBEstimators, freq = F)
plot(p1, col=rgb(0,0,1,1/4), xlim=c(-100,100),
main = "Monte Carlo: Naive versus RB",
xlab = "estimator value")  # first histogram
plot(p2, col=rgb(1,0,0,1/4), xlim=c(-100,100), add=T)  # second
# compare the three estimators
p1 <- hist(regMonteCarloEstimators, probability = T)
p2 <- hist(RBEstimators, probability = T)
# compare the three estimators
p1 <- hist(regMonteCarloEstimators, probability = T, plot = F)
p2 <- hist(RBEstimators, probability = T, plot = F)
# compare the three estimators
p1 <- hist(regMonteCarloEstimators, probability = T)
p2 <- hist(RBEstimators, probability = T)
plot(p1, col=rgb(0,0,1,1/4), xlim=c(-100,100),
main = "Monte Carlo: Naive versus RB",
xlab = "estimator value")  # first histogram
plot(p2, col=rgb(1,0,0,1/4), xlim=c(-100,100), add=T)  # second
abline(v=dataMean, col = "red") # actual posterior predictive mean (no sampling error)
legend(x = "topright",
legend = c("monte-carlo", "rb monte-carlo"),
fill = c(rgb(0,0,1,1/4),
rgb(1,0,0,1/4)))
plot(cars)
library(quantmod)
dfs <- lapply(symbols,
function(s) getSymbols(s, env = NULL, auto.assign=F))
dfs <- lapply(symbols,
function(s) getSymbols(s, env = NULL, auto.assign=F))
symbols <- c("SPY", "QQQ")
dfs <- lapply(symbols, function(s) print(s))#getSymbols(s, env = NULL, auto.assign=F))
dfs <- lapply(symbols, function(s) getSymbols(s, env = NULL, auto.assign=F))
close_prices <- lapply(dfs, function(df) Ad(df))
close_prices <- data.frame(lapply(dfs, function(df) Ad(df)))
plot.ts(close_prices)
plot.ts(log_prices)
log_prices <- log(close_prices)
plot.ts(log_prices)
library(xts)
dailyReturn(close_prices)
close_prices <- as.data.frame(lapply(dfs, function(df) Ad(df)))
head(close_prices)
returns <- apply(close_prices, dailyReturn)
returns <- apply(close_prices, 2, dailyReturn)
returns <- apply(close_prices, 1, dailyReturn)
head(close_prices)
apply(X = close_prices, MARGIN = 1, FUN = dailyReturn)
apply(X = close_prices, MARGIN = 1, FUN = dailyReturn)
close_prices <- as.xts(lapply(dfs, function(df) Ad(df)))
n <- nrow(close_prices)
close_prices[-n]
(close_prices[-n] - close_prices[-1])/close_prices[-1]
(close_prices[-n,] - close_prices[-1,])/close_prices[-1,]
returns <- 100*(close_prices[-n,] - close_prices[-1,])/close_prices[-1,]
plot(returns)
library(quantmod)
library(xts)
symbols <- c("SPY", "QQQ")
dfs <- lapply(symbols, function(s) getSymbols(s, env = NULL, auto.assign=F))
close_prices <- as.data.frame(lapply(dfs, function(df) Ad(df)))
n <- nrow(close_prices)
returns <- 100*(close_prices[-n,] - close_prices[-1,])/close_prices[-1,]
plot(returns)
library(quantmod)
library(xts)
symbols <- c("SPY", "QQQ")
dfs <- lapply(symbols, function(s) getSymbols(s, env = NULL, auto.assign=F))
close_prices <- as.data.frame(lapply(dfs, function(df) Ad(df)))
n <- nrow(close_prices)
returns <- 100*(close_prices[-n,] - close_prices[-1,])/close_prices[-1,]
plot(returns)
plot.ts(returns)
library(quantmod)
library(xts)
symbols <- c("SPY", "QQQ")
dfs <- lapply(symbols, function(s) getSymbols(s, env = NULL, auto.assign=F))
close_prices <- as.data.frame(lapply(dfs, function(df) Ad(df)))
n <- nrow(close_prices)
returns <- 100*(close_prices[-n,] - close_prices[-1,])/close_prices[-1,]
plot(returns)
head(returns)
head(coredat(returns))
head(coredata(returns))
cov(returns)
library(MCMCpack)
install.packages("MCMCpack")
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 100), # Sigma/kappa0
if(!require(MCMCpack)) install.packages("MCMCpack"); library(MCMCpack)
if(!require(MASS)) install.packages("MASS"); library(MASS)
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 100)) # Sigma/kappa0
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 100) # Sigma/kappa0
# draw y from the likelihood
ysamp <- mvrnorm(n = 1,
mu,
Sigma)
return(ysamp)
}
fake_return_data <- replicate(num_samples, SimData())
num_samples <- 1000
fake_return_data <- replicate(num_samples, SimData())
fake_return_data <- replicate(num_samples, simData())
head(transpose(fake_return_data))
head(t(fake_return_data))
plot(fake_return_data)
plot(t(fake_return_data))
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 1000) # Sigma/kappa0
# draw y from the likelihood
ysamp <- mvrnorm(n = 1,
mu,
Sigma)
return(ysamp)
}
num_samples <- 1000
fake_return_data <- replicate(num_samples, simData())
plot(t(fake_return_data))
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
print(Sigma[0,0])
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 1000) # Sigma/kappa0
# draw y from the likelihood
ysamp <- mvrnorm(n = 1,
mu,
Sigma)
return(ysamp)
}
num_samples <- 1000
fake_return_data <- replicate(num_samples, simData())
riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
derp <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
class(derp)
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(20, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 1000) # Sigma/kappa0
# draw y from the likelihood
ysamp <- mvrnorm(n = 1,
mu,
Sigma)
return(ysamp)
}
num_samples <- 1000
fake_return_data <- replicate(num_samples, simData())
plot(t(fake_return_data))
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(2, # degrees of reedom
matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, # num vectors we draw
c(0,0), # mu0 prior mean
Sigma / 1000) # Sigma/kappa0
# draw y from the likelihood
ysamp <- mvrnorm(n = 1,
mu,
Sigma)
return(ysamp)
}
num_samples <- 1000
fake_return_data <- replicate(num_samples, simData())
plot(t(fake_return_data))
colMeans(returns)
n <- nrow(returns)
ybar <- colMeans(returns)
mu_n <- kappa_0/(kappa_0 + n)*mu_0 + n/(kappa_0 + n)*ybar
# choose hyper-parameters
kappa_0 <- 1000
nu_0 <- 2    # degrees of reedom
Lambda_0 <- matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
mu_0 <- c(0,0)
ybar <- colMeans(returns)
n <- nrow(returns)
mu_n <- kappa_0/(kappa_0 + n)*mu_0 + n/(kappa_0 + n)*ybar
mu_n
ybar
mu_0
kappa_0/(kappa_0 + n)
n/(kappa_0 + n)
1 + cumprod(returns)
nu_n <- nu_0 + n
mu_n <- kappa_0/(kappa_0 + n)*mu_0 + n/(kappa_0 + n)*ybar
kappa_n <- kappa_0 + n
nu_n <- nu_0 + n
(ybar - mu_0)%*%(ybar - mu_0)
ybar
mu_0
ybar <- matrix(colMeans(returns))
ybar
(ybar - mu_0)%*%(ybar - mu_0)
Lambda_n <- Lambda_0 + S + (kappa_0*n)/(kappa_0 + n)*(ybar - as.matrix(mu_0))%*%(ybar - as.matrix(mu_0))
S <- (n-1)*cov(returns)
S
ybar <- matrix(colMeans(returns))
n <- nrow(returns)
S <- (n-1)*cov(returns)
kappa_n <- kappa_0 + n
nu_n <- nu_0 + n
Lambda_n <- Lambda_0 + S + (kappa_0*n)/(kappa_0 + n)*(ybar - as.matrix(mu_0))%*%(ybar - as.matrix(mu_0))
(ybar - as.matrix(mu_0))%*%(ybar - as.matrix(mu_0))
Lambda_n <- Lambda_0 + S + (kappa_0*n)/(kappa_0 + n)*(ybar - as.matrix(mu_0))%*% t((ybar - as.matrix(mu_0)))
simPosteriorCorr <- function(){
# draw Sigma from p(Sigma | y)
Sigma <- riwish(nu_n, Lambda_n)
# draw mu from p(mu | Sigma, y)
mu <- mvrnorm(n = 1, mu_n, Sigma / kappa_n)
var1 <- Sigma[1,1]
var2 <- Sigma[2,2]
covar <- Sigma[1,2]
return(covar/sqrt(var1*var2))
}
hist(replicate(1000, simPosteriorCorr()))
library(quantmod)
library(xts)
symbols <- c("SPY", "QQQ")
dfs <- lapply(symbols, function(s) getSymbols(s, env = NULL, auto.assign=F))
close_prices <- as.data.frame(lapply(dfs, function(df) Ad(df)))
n <- nrow(close_prices)
returns <- 100*(close_prices[-n,] - close_prices[-1,])/close_prices[-1,]
plot(returns)
if(!require(MCMCpack)) install.packages("MCMCpack"); library(MCMCpack)
if(!require(MASS)) install.packages("MASS"); library(MASS)
# choose hyper-parameters
kappa_0 <- 1000
nu_0 <- 2    # degrees of reedom
Lambda_0 <- matrix(c(1, .8, .8, 1), nrow=2) # scale matrix
mu_0 <- c(0,0)
# a function that draws from p(y) = \int \int p(y \mid \mu, Sigma)p(\mu \mid Sigma)p(\Sigma) d mu d Sigma
simData <- function(){
# draw Sigma from p(Sigma)
Sigma <- riwish(nu_0, Lambda_0)
# draw mu from p(mu | Sigma)
mu <- mvrnorm(n = 1, mu_0, Sigma / kappa_0)
# draw y from the likelihood
ysamp <- mvrnorm(n = 1, mu, Sigma)
return(ysamp)
}
num_samples <- 1000
fake_return_data <- replicate(num_samples, simData())
plot(t(fake_return_data))
ybar <- matrix(colMeans(returns))
n <- nrow(returns)
S <- (n-1)*cov(returns)
mu_n <- kappa_0/(kappa_0 + n)*mu_0 + n/(kappa_0 + n)*ybar
kappa_n <- kappa_0 + n
nu_n <- nu_0 + n
Lambda_n <- Lambda_0 + S + (kappa_0*n)/(kappa_0 + n)*(ybar - as.matrix(mu_0))%*% t((ybar - as.matrix(mu_0)))
simPosteriorCorr <- function(){
# draw Sigma from p(Sigma | y)
Sigma <- riwish(nu_n, Lambda_n)
# draw mu from p(mu | Sigma, y)
mu <- mvrnorm(n = 1, mu_n, Sigma / kappa_n)
var1 <- Sigma[1,1]
var2 <- Sigma[2,2]
covar <- Sigma[1,2]
return(covar/sqrt(var1*var2))
}
hist(replicate(1000, simPosteriorCorr()))
