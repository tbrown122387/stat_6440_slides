library(invgamma)
?dinvgamma()
yi_minus_mu <- .1
dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2))
v <- seq(0,5,.1)
ss <- .001
yi_minus_mu <- .1
dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2))
# data
y <- c(-0.59836613, -0.10194784, -0.06399318,  0.41957954,
-0.98565345, -0.09350700,  1.75391375,  0.79859181,
0.32095243, 0.72231544)
nu <- 5
# function that evaluates log posteriors
eval_log_unnormalized_posterior <- function(mu, ss){
zsquareds <- (y - mu)*(y - mu)/ss
lds <- -.5*(nu+1) * log( 1 + zsquareds/nu )
sum(lds) - log(ss)
}
# graph parameters
plotSurface <- function(lowerFirst, upperFirst,
lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...){
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
contour(A, B, z)
}else{
persp(x=A, y=B, z=z, ...)
}
}
plotSurface(-50, 50, 0.0001, 50, 20, eval_log_unnormalized_posterior, F,
theta=-120, zlab = "log unnorm dens", xlab = "mu", ylab = "ss")
v <- seq(0,5,.1)
ss <- .001
yi_minus_mu <- .1
dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2))
v <- seq(.001,5,.1)
ss <- .001
yi_minus_mu <- .1
dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2))
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)))
v <- seq(.001,.5,.01)
ss <- .001
yi_minus_mu <- .1
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)))
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)), type = "l")
yi_minus_mu <- 1
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)), type = "l")
yi_minus_mu <- .1
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)), type = "l")
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "vi | mu, ss, y")
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "vi | mu, ss, y", ylab = "dens")
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "vi | mu, ss, y", ylab = "density")
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "p(vi | mu, ss, y)", ylab = "density")
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "p(v_1 | mu, ss, y)", ylab = "density")
v <- seq(.001,.5,.01)
ss <- .001
yi_minus_mu <- .1
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "p(v_1 | mu, ss=.001, y)", ylab = "density")
ss <- .01
yi_minus_mu <- .1
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "p(v_1 | mu, ss=.001, y)", ylab = "density")
plot(v, dinvgamma(v, shape=(nu+1)/2, .5*(nu*ss + (yi_minus_mu)^2)),
type = "l", main = "p(v_1 | mu, ss=.01, y)", ylab = "density")
plot(v, dgamma(v, shape=1, rate=1000), type = "l")
# generate fake data
real_mu <- 5
real_ss <- 2
n <- 10
y <- rnorm(n, mean = real_mu, sd = sqrt(real_ss))
ssquared <- var(y)
ybar <- mean(y)
# find posterior mode with BFGS (a Quasi-Newton approach)
# Recall quasi-Newton only uses first derivatives of the log-likelihood
neg_log_unnorm_post <- function(params){
mu <- params[1]
theta <- params[2]
chunk <- (n-1)*ssquared + n*(ybar - mu)^2
n*theta + .5*exp(-2*theta + log(chunk))
}
neg_gradient <- function(params){
mu <- params[1]
theta <- params[2]
c(
-exp(-2*theta)*n*(ybar - mu),
n - exp(-2*theta)*( (n-1)*ssquared + n*(ybar - mu)^2 )
)
}
optim_results <- optim(par = c(5, 0),
fn = neg_log_unnorm_post,
gr = neg_gradient, # if left blank, finite difference approx. used
method = "BFGS",
hessian = T)
if(optim_results$convergence==0){
cat('successfully converged\n')
cat('mode: mu = ', optim_results$par[1], ', and ss = ', exp(2*optim_results$par[2]), '\n')
}
# normal approximation to p(mu, theta | y
approx_mean <- optim_results$par
approx_cov_mat <- solve(optim_results$hessian)
approx_corr_mat <- cov2cor(approx_cov_mat)
unnorm_dens <- function(mu, log_sigma){
params <- c(mu, log_sigma)
lup <- exp(-neg_log_unnorm_post(params))
}
library(mvtnorm)
norm_approx_dens <- function(mu, log_sigma){
dmvnorm(x = c(mu, log_sigma), mean = approx_mean, sigma = approx_cov_mat)
}
plotSurface <- function(lowerFirst, upperFirst,
lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...){
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
contour(A, B, z)
}else{
persp(x=A, y=B, z=z, ...)
}
}
# real but unnormalized
plotSurface(3,6,0,1.25,numGridPointsOnEachAxis = 50, f = unnorm_dens, contour = T)
title("Unnormalized true p(mu, theta | y)", font = 4)
plotSurface(3,6,0,1.25,numGridPointsOnEachAxis = 50, f = norm_approx_dens, contour = T)
title("Normal approx. p(mu, theta | y)", font = 4)
# compare posteriors
poss_mus <- seq(-2*abs(mu), 2*abs(mu), length.out = 100)
real_posterior <- dnorm(x = poss_mus, mean = mean(y), sd = 1/sqrt(length(y)))
